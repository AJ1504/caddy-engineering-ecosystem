import React, { useEffect, useRef } from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

type ComponentType = {
  name: string;
  type: "cylinder" | "torus" | "box" | "sphere" | "cone";
  material?: string;
  hollow?: boolean;
  dimensions: Record<string, number>;
  position: { x: number; y: number; z: number };
  rotation: { x: number; y: number; z: number };
};

type ModelSchema = {
  object_analysis: string;
  components: ComponentType[];
};

export default function ThreeJSViewer({ schema }: { schema: ModelSchema | null }) {
  const mountRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!schema || !mountRef.current) return;

    const width = mountRef.current.clientWidth;
    const height = mountRef.current.clientHeight;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.set(150, 150, 150);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    mountRef.current.innerHTML = "";
    mountRef.current.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 50, 0);
    controls.update();

    const ambientLight = new THREE.AmbientLight(0x888888);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(100, 200, 100);
    scene.add(directionalLight);

    // Material presets
    const materials: Record<string, THREE.Material> = {
      ceramic: new THREE.MeshStandardMaterial({ color: 0xd2b48c, roughness: 0.7 }),
      plastic: new THREE.MeshStandardMaterial({ color: 0x3333ff, roughness: 0.6 }),
      metal: new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.2, metalness: 0.8 }),
      default: new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5 }),
    };

    function createMesh(c: ComponentType) {
      let geometry: THREE.BufferGeometry;
      const d = c.dimensions;
      switch (c.type) {
        case "cylinder":
          geometry = new THREE.CylinderGeometry(d.radius || 10, d.radius || 10, d.height || 20, 32);
          break;
        case "torus":
          geometry = new THREE.TorusGeometry(d.major_radius || 10, d.minor_radius || 3, 16, 100);
          break;
        case "box":
          geometry = new THREE.BoxGeometry(d.width || 10, d.height || 10, d.depth || 10);
          break;
        case "sphere":
          geometry = new THREE.SphereGeometry(d.radius || 10, 32, 32);
          break;
        case "cone":
          geometry = new THREE.ConeGeometry(d.radius || 10, d.height || 20, 32);
          break;
        default:
          return null;
      }

      const mat = materials[c.material ?? "default"] ?? materials.default;
      const mesh = new THREE.Mesh(geometry, mat);

      mesh.position.set(c.position.x, c.position.y, c.position.z);
      mesh.rotation.set(c.rotation.x, c.rotation.y, c.rotation.z);

      return mesh;
    }

    schema.components.forEach((comp) => {
      const mesh = createMesh(comp);
      if (mesh) scene.add(mesh);
    });

    const animate = () => {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    };

    animate();

    return () => {
      mountRef.current?.removeChild(renderer.domElement);
      renderer.dispose();
    };
  }, [schema]);

  return <div ref={mountRef} style={{ width: "100%", height: "100%" }} />;
}
